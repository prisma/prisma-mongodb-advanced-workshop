# Update your schema

## Goal

The goal of this lesson is to update your schema to include the collections you need to store your kudos data. You will need to set up relations between the `User` and `Kudo` models, as well as put referential actions in place to ensure referential integrity.

## Setup

None needed!

## Hints

- ***Type yourself*, don't copy and paste**
    
    To learn and really *understand* what you are doing for each task, be sure to **not copy and paste the solution** but type out the solution yourself (even if you have to look it up). 
    
- **Use the autocompletion**
    
    Prisma Client provides a number of queries that you can send to your database using its API. You can learn about these queries in the [documentation](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client) or explore the API right in your editor using *autocompletion*.
    
    To invoke the autocompletion, you can open `src/index.ts` and type following *inside* of the `main` function (you can delete the comment `// ... your Prisma Client queries will go here` that's currently there):
    
    ```tsx
    import { PrismaClient } from '@prisma/client'
    
    const prisma = new PrismaClient()
    
    async function main() {
      const result = await **prisma.** // autocompletion will show up if you type this
    }
    
    main()
      .catch((e) => console.error(e))
      .finally(async () => await prisma.$disconnect())
    ```
    
    - Expand for a screenshot of the autocompletion
        
        ![images/Untitled.png](./images/Untitled.png)
        
    
    Once you typed the line `const result = await prisma.` ****into your editor, a little popup will be shown that lets you select the options for composing a query (e.g.  selecting a *model* you want to query or using another top-level function like `$queryRaw` or `$connect`). Autocompletion is available for the *entire* query, including any arguments that you might want to provide!
    
- **Visualize data in Prisma Studio**

## Tasks

### Task 1: Add enums for kudo style values

Before you define the model for the kudos users can send each other, you will need to create a few enums that define possible values for a few of those kudos’ styling options.

`Color` : This enum will have the values:

- `RED`
- `GREEN`
- `YELLOW`
- `BLUE`
- `WHITE`

`Emoji`: This enum will have the values:

- `THUMBSUP`
- `PARTY`
- `HANDSUP`

Define those in your schema.

- Solution
    
    ```graphql
    enum Emoji {
      THUMBSUP
      PARTY
      HANDSUP
    }
    
    enum Color {
      RED
      GREEN
      YELLOW
      BLUE
      WHITE
    }
    ```
    

### Task 2: Add your `Kudo` model

All of your user-related data is being stored properly in your database at this point. Now you need to define the schema for the kudos users can send to each other. 

Add a model to your schema named `Kudos` with the following fields:

- `id` : The unique ID generated by MongoDB (named `_id` in the underlying database)
- `message` : The content of the message being sent
- `createdAt` : A timestamp set when the record is created
- `style` : An embedded document containing the fields:
    - `backgroundColor` :  Uses the `Color` enum
    - `textColor` : Uses the `Color` enum
    - `emoji` : Uses the `Emoji` enum
- Solution
    
    ```graphql
    model Kudo {
      id        String    @id @default(auto()) @map("_id") @db.ObjectId
      message   String
      createdAt DateTime  @default(now())
      style     KudoStyle
    }
    
    type KudoStyle {
      backgroundColor Color @default(YELLOW)
      textColor       Color @default(WHITE)
      emoji           Emoji @default(THUMBSUP)
    }
    ```
    

### Task 3: Create `author` and `recipient` relationships

In your application, a user (or *author*) can send many kudos. They can also receive many kudos from other users.

You will need to define these one-to-many relationships in your schema. 

In the `User` model, add two relationship fields that define ownership of *many* `Kudos`. 
You will need to name each relationship because you are setting up two relations between the same tables. 

The naming of the relationships and fields will be important to the application’s code so I’ve provided those below.

Relationship names: `AuthoredKudos` and `RecievedKudos`

Field names on the `User` model: `authoredKudos` and `kudos`

Field names on the `Kudo` model: `author`, `authorId`, `recipient`, `recipientId`

- Solution
    
    ```graphql
    model User {
      id            String   @id @default(auto()) @map("_id") @db.ObjectId
      createdAt     DateTime @default(now())
      updatedAt     DateTime @updatedAt
      email         String   @unique
      password      String
      profile       Profile
      authoredKudos Kudo[]   @relation("AuthoredKudos")
      kudos         Kudo[]   @relation("RecievedKudos")
    }
    
    model Kudo {
      id          String    @id @default(auto()) @map("_id") @db.ObjectId
      message     String
      createdAt   DateTime  @default(now())
      style       KudoStyle
      author      User      @relation(references: [id], fields: [authorId], "AuthoredKudos")
      authorId    String    @db.ObjectId
      recipient   User      @relation(references: [id], fields: [recipientId], "RecievedKudos")
      recipientId String    @db.ObjectId
    }
    ```
    

### Task 4: Put a referential action in place

Your relationships are defined, however at this point they don’t have very strong referential integrity. If a `User` who had many `Kudos` was deleted, that user’s `Kudos` would remain in the database as stale, or orphan, data.

Add a referential action to the `AuthoredKudos` relationship that cascades delete events.

- Solution
    
    ```graphql
    model Kudo {
      id          String    @id @default(auto()) @map("_id") @db.ObjectId
      message     String
      createdAt   DateTime  @default(now())
      style       KudoStyle
      author      User      @relation(references: [id], fields: [authorId], onDelete: Cascade, "AuthoredKudos")
      authorId    String    @db.ObjectId
      recipient   User      @relation(references: [id], fields: [recipientId], "RecievedKudos")
      recipientId String    @db.ObjectId
    }
    ```
    

### Task 5: Regenerate Prisma Client

- Solution
    
    ```tsx
    npx prisma db push
    ```